# **java学习**

## 成员变量和局部变量区别：
* ####  1.作用域不同   
>&emsp;局部变量的作用域仅限于定义他的方法   
&emsp;成员变量的作用域在整个类内部都是可见的

* #### 2.初始值不同   
>&emsp;java会给成员变量一个初始值   
&emsp;java不会给局部变量赋予初始值

* #### 3.在同一个方法中,不允许有同名局部变量；在不同的方法中，可以有同名局部变量

* #### 4.两类变量同名时,局部变量具有更高的优先级


## <font color=#5F9EA0> 构造方法（构造函数）：</font>
+ #### <font color=#5F9EA0> 1.使用new+构造方法，创建一个新的对象</font>

+ #### <font color=#5F9EA0> 2.构造方法是定义在java类中的一个用来初始化对象的方法 构造方法与类同名且没有返回值</font>
![](https://github.com/W-Avan/java/raw/master/pic/1.png)
![](https://github.com/W-Avan/java/raw/master/pic/2.png)

+ #### <font color=#5F9EA0> 4.有参构造方法即在()声明参数，可与无参构造方法共存</font>

+ #### <font color=#5F9EA0> 5.当没有指定构造方法时，系统会自动添加无参的构造方法<font>

+ #### <font color=#5F9EA0> 6.当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法（即不存在系统默认的构造方法）</font>

+ #### <font color=5F9EA0> 7.构造方法的**重载**：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法</font>

+ #### <font color=5F9EA0> 8.构造方法不但可以给对象属性赋值，还可以保证给对象的属性赋一个合理的值（详情见E:\eclipse\project2\src\com\imooc\InitailTelephone.java运行结果）</font>


## Static 静态变量、静态方法和静态初始化块：
+ #### 1.静态变量
&emsp; java中被static修饰的的成员成为静态成员或 **类成员** <font color=#FF0000>它属于整个类所有，不属于某个对象，被所有对象共享，可以用类名直接访问(当系统第一次使用这个类，就为该静态成员分配内存空间，直到该类被卸载才会资源回收)</font>

+ #### 2.静态方法
>&emsp;例：public **static** void print(){...}  
&emsp;<font color=#FF0000>注意：</font>  
&emsp;
a.**静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员**（如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量)  
&emsp;
b.在普通成员方法中，则可以直接访问同类的非静态变量和静态变量  
&emsp;
c.**静态方法中不能直接调用非静态方法**，需要通过对象来访问非静态方法

+ #### 3.静态初始化块
>&emsp; 类的声明中可以包含多个初始化块，每个初始化块由{...}组成那个创建类的实例时，就会依次执行这些代码。如果使用static修饰初始化块，就称为静态初始化块  
&emsp;<font color=#FF0000>注意：</font>  
&emsp;
**静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量**  
如图：  ![](https://github.com/W-Avan/java/raw/master/pic/3.jpg)

## Java中的包：
+ #### 1.包的作用  
>管理Java文件  
解决同名文件冲突

+ #### 2.定义包：package包名  
>注：必须放在Java源程序第一行  
包名间可以使用"."号隔开    
eg: com.imooc.MyClass

+ #### 3.系统中的包
>java.(功能).(类)  
java.lang.(类) <font color=#5F9EA0>包含java语言基础的类</font>  
java.util.(类) <font color=#5F9EA0>包含java语言中各种工具类</font>  
java.io.(类) <font color=#5F9EA0>包含输入、输出相关功能的类</font>

+ #### 4.包的使用  
>(1)可以通过import关键字，在某个文件使用其他文件中的类。  
&emsp;import com.imooc.music.MyClass  
(2)Java中,包的命名规范是全小写字母拼写  
(3)使用的时候不但可以加载某个包下的所有文件  
&emsp;eg: com.imooc.*****  
&emsp;也可以加载某个具体子包下的所有文件  
&emsp;eg: com.imooc.music.*

## Java中的内部类  
+ #### 内部类可分为以下四种：
> + 成员内部类  
> + 静态内部类  
> + 方法内部类  
> + 匿名内部类

+ #### 成员内部类
> + 内部类中可以直接访问外部类中的数据，而不受访问控制符的影响（外部类中private成员，内部类可直接调用）  
> + 外部类不能直接使用内部类的成员和方法  
> + 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，<font color=#FF0000>如果要访问外部类的成员变量，可以使用this关键字,(out.this.b)</font>


+ #### 静态内部类(static)
> + 静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员 的方式访问  
> + 若外部类的静态成员与内部类的成员名相同，可通过"类名.静态成员" 访问外部类的静态成员(与成员内部类不同的是不用加this);若外部类的静态成员与内部类的成员名不相同，则可通过"成员名"直接调用外部类的静态成员
> + 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 **内部类 对象名 = new 内部类();**

+ #### 方法内部类
> + 内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，及只在该方法内部可以使用，因此方法内部类不能使用访问控制符和static修饰符。(直接定义class xxx（）)

## Java中的继承  
+ #### <font color=#FF0000>Java中的继承是单继承</font>
+ #### 子类拥有父类的所有属性和方法(<font color=#ff0000>属性和方法的修饰符不能为private，这一点同C++</font>)  
+ #### 语法规则：  
> class 子类 <font color=#ff0000>extends</font> 父类  
> 例：class Dog extends Animal{...}

+ #### 方法的重写  
> 1.什么是方法的重写：  
> 如果子类对继承父类的方法不满意，是可以重写父类继承的方法的，当调用方法时会优先调用子类的方法。  
> 2.语法规则：  
> a.返回值类型  
> b.方法名  
> c.参数类型及个数  
> 都要与父类继承的方法相同，才叫方法的重写  

+ #### 继承初始化顺序  
> 1.初始化父类再初始化子类  
> 2.先执行初始化对象中属性，再执行构造方法中的初始化

+ #### final的使用  
> + ##### final关键字  
> &emsp;使用final关键字做标识有“最终的”含义  
> + ##### final可以修饰类、方法、属性和变量  
>> +  final修饰类，则该类不允许被继承  
>> + final修饰方法，则该方法不允许被覆盖(重写)  
>> + final修饰属性  
>> &emsp;则该类的属性不会进行隐式的初始化(类的初始化属性必须有值)  
>> &emsp;或在构造方法中赋值(但只能选其一)  
>> + final修饰变量，则该变量的值只能赋一次值，即变为量

+ #### super的使用  
> ##### super关键字  
> &emsp;在对象的内部使用，可以代表父类对象  
> ##### 1.访问父类的属性  
> &emsp;super.age  
> ##### 2.访问父类的方法  
> &emsp;super.eat()
> ##### 子类的构造的过程中必须调用其父类的构造方法  
> ##### 如果子类的构造方法中没有 显示调用父类的构造方法(super())，则系统默认调用父类无参的构造方法  
> ##### 如果显示的调用构造方法，必须在子类的构造方法的第一行(super())  
> ##### 如果子类构造方法中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译错误

+ #### Object类  
Object类是所有类的父亲，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类。  
Object类中的方法，适合所有子类。
> ##### 1.toString()方法  
> 在Object类里定义toString()方法的时候返回的对象的哈希code码(对象地址字符串)
> ![](https://github.com/W-Avan/java/raw/master/pic/4.png)  
> 可以通过重写toString()方法表示出对象的属性
> ##### 2.equals()方法  
> 比较的是对象的**引用**是否指向同一块内存地址。  
> Dog dog = new Dog()  
> 一般情况下比较两个对象时比较它的值是否一致，所以要进行重写。(source中有直接写好的)

## Java中的多态  
+ #### 对象的多种形态（<font color=#FF0000>继承是多态的实现基础</font>）  
> 1.引用多态  
&emsp;父类的引用可以指向本类的对象  
&emsp;父类的引用可以指向子类的对象(子类的引用不能指向父类的对象)
> 2.方法多态  
&emsp;创建本类对象时，调用的方法为本类方法  
&emsp;创建子类对象时，调用的方法为子类重写的方法或者继承的方法(不能调用子类中独有父类中没有的方法)

+ #### 引用类型转换
> 1.向上类型转换(隐式/自动类型转换)，是小类型到大类型的转换，不存在风险  
> 2.向下类型转换(强制类型转换)，是大类型到小类型
> 3.
instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题 (具体见project4)

+ #### 抽象类
> 1.语法定义：  
&emsp;抽象类前使用abstract关键字修饰，则该类为抽象类  
> 2.应用场景：  
&emsp;a.在某些情况下，某个弗雷只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。  
&emsp;b.从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。  
> 3.作用：  
&emsp;限制规定子类必须实现某些方法，但不关注实现细节。  
> 4.使用规则：  
&emsp;a.abstract定义抽象类  
&emsp;b.abstract定义抽象方法，<font color=#FF0000>只有声明，不需要实现</font>  
&emsp;c.包含抽象方法的类是抽象类  
&emsp;d.抽象类中可以包含普通的方法，也可以没有抽象方法  
&emsp;e.抽象类不能直接创建，可以定义引用变量(引用多态)

+ #### 接口
> ##### 1.接口概念：  
&emsp;类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。  
> ##### 2.接口定义：  
&emsp;和类定义不同，定义接口不再使用class关键字，而是使用interface关键字。  
> 接口定义的基本语法：  
> [修饰符] interface 接口名 [extends 父接口1,父接口2...]  
{  
&emsp;零个到多个常量定义...  
&emsp;零个到多个抽象方法的定义...  
}  
接口就是用来被继承、被实现的，修饰符一般建议用<font color=#FF0000>public</font>  
> <font color=#ff0000>注意：</font>不能使用<font color=#ff0000>private</font>和<font color=#ff0000>protected</font>修饰接口，接口定义不写方法体，只声明。  
> #### 3.接口定义  
> &emsp;**常量：**  
&emsp;接口中的属性是常量，即使定义时不添加public static final 修饰符，系统也会自动加上。  
> &emsp;**方法：**  
&emsp;接口中的方法只能是抽象方法，总是使用，即使定义时不添加public abstract 修饰符，系统也会自动加上。  
> #### 4.使用接口  
&emsp;一个类可以实现一个或多个接口，实现接口使用**implements**关键字。Java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口可以做补充。  
> ##### 继承父类实现接口的语法为：  
[修饰符] class 类名 <font color=#ff0000>extends</font> 父类 <font color=#ff0000>implements</font> 接口1，接口2...    
{  
&emsp;类体部分//如果继承了抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法。  
}  
> 如果要继承父类，继承父类必须在实现接口之前  
> ##### 使用接口：  
&emsp;接口在使用过程当中，还经常与匿名内部类配合使用  
&emsp;匿名内部类就是没有名字的内部类  
&emsp;多用于关注实现而不关注实现类的名称  
>> 语法格式：  
&emsp;interface i = new Interface(){  
&emsp;  public void method(){  
&emsp;   System.out.println("匿名内部类实现接口的方式");  
  &emsp;}  
}

+ #### UML简介  
> ##### 1.UML概念  
&emsp;Unified Modeling Language(UML)  
&emsp;又称统一建模语言或标准建模语言  
&emsp;是一个支持模型化和软件系统开发的图形化语言  
&emsp;为软件开发的所有阶段提供模型化和可视化支持  
> ##### 2.UML图示  
&emsp;UML2.2中一共定义了14中图示(diagrams)。  
> ##### 3.常用UML图
> + 用例图(The Use Case Diagram)  
&emsp;用例图能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求等信息。   
![](https://github.com/W-Avan/java/raw/master/pic/5.png)    
> + 序列图(The Sequence Diagram)  
&emsp;序列图用于按照交互发生的一系列顺序，显示对象之间的这些交互。
![](https://github.com/W-Avan/java/raw/master/pic/6.png)  
> + 类图(The Class Diagram)  
&emsp;UML类图、业务逻辑和所有支持结构一同被用于定义全部的代码结构。  
![](https://github.com/W-Avan/java/raw/master/pic/7.png)   
> 4.UML建模工具  
&emsp;Visio、Rational Rose、PowerDesign三种建模工具应用最广
